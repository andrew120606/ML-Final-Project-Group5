#%%------------------------------------------------------------------------------------------------------------------------
# model part
# boosting model
from sklearn.experimental import enable_hist_gradient_boosting
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.metrics import precision_recall_fscore_support

hgbc = HistGradientBoostingClassifier(random_state=42)
hgbc.fit(X_train, y_train)

y_valid_pred = hgbc.predict(X_test)
y_valid_pred_score = hgbc.predict_proba(X_test)

precision, recall, fscore, support = precision_recall_fscore_support(y_test, y_valid_pred, average='micro')

print(classification_report(y_test,y_valid_pred))
print("Accuracy:", accuracy_score(y_test, y_valid_pred) * 100)
print("ROC_AUC : ", roc_auc_score(y_test,y_valid_pred_score[:,1]) * 100)
# confusion matrix
conf_matrix = confusion_matrix(y_test, y_valid_pred)
df_cm = pd.DataFrame(conf_matrix, index=['0','1'], columns=['0','1'] )

plt.figure(figsize=(5,5))
hm = sns.heatmap(df_cm, cbar=False, annot=True, square=True, fmt='d', annot_kws={'size': 20}, yticklabels=df_cm.columns, xticklabels=df_cm.columns)
hm.yaxis.set_ticklabels(hm.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=20)
hm.xaxis.set_ticklabels(hm.xaxis.get_ticklabels(), rotation=0, ha='right', fontsize=20)
plt.ylabel('True label',fontsize=20)
plt.xlabel('Predicted label',fontsize=20)
plt.tight_layout()
plt.show()
# Plot ROC Area Under Curve
fpr, tpr, _ = roc_curve(y_test, y_valid_pred_score[:,-1])
auc = roc_auc_score(y_test, y_valid_pred_score[:,-1])
plt.figure()
lw = 2
plt.plot(fpr, tpr, color='darkorange',
         lw=lw, label='ROC curve (area = %0.2f)' % auc)
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC curve')
plt.legend(loc="lower right")
plt.show()

#%%------------------------------------------------------------------------------------
## Modeling
### logistic regression
from sklearn.linear_model import LogisticRegression
logt = LogisticRegression()
logt.fit(X_train,y_train)
y_valid_pred2 = logt.predict(X_test)
y_valid_pred2_score = logt.predict_proba(X_test)
print(classification_report(y_test,y_valid_pred2))
print("Accuracy : ", accuracy_score(y_test, y_valid_pred2) * 100)
print("ROC_AUC : ", roc_auc_score(y_test,y_valid_pred2_score[:,1]) * 100)
### confusion matrix
conf_matrix = confusion_matrix(y_test, y_valid_pred2)

df_cm = pd.DataFrame(conf_matrix, index=['0','1'], columns=['0','1'] )

plt.figure(figsize=(5,5))
hm = sns.heatmap(df_cm, cbar=False, annot=True, square=True, fmt='d', annot_kws={'size': 20}, yticklabels=df_cm.columns, xticklabels=df_cm.columns)
hm.yaxis.set_ticklabels(hm.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=20)
hm.xaxis.set_ticklabels(hm.xaxis.get_ticklabels(), rotation=0, ha='right', fontsize=20)
plt.ylabel('True label',fontsize=20)
plt.xlabel('Predicted label',fontsize=20)
plt.tight_layout()
plt.show()

#%%------------------------------------------------------------------
# Plot ROC Area Under Curve
fpr, tpr, _ = roc_curve(y_test, y_valid_pred2_score[:,-1])
auc = roc_auc_score(y_test, y_valid_pred2_score[:,-1])

plt.figure()
lw = 2
plt.plot(fpr, tpr, color='darkorange',
         lw=lw, label='ROC curve (area = %0.2f)' % auc)
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC curve')
plt.legend(loc="lower right")
plt.show()

#%%------------------------------------------------------------------
# GUI code

import tkinter as tk
from tkinter import ttk
import tkinter.font as tkFont


from sklearn.linear_model import LogisticRegression
from matplotlib.pyplot import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from sklearn.experimental import enable_hist_gradient_boosting
from sklearn.ensemble import HistGradientBoostingClassifier

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder


from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
from sklearn.metrics import accuracy_score, roc_auc_score

from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier


class Application(tk.Tk):
    def __init__(self):
        super().__init__()
        self.createWidget()
        self.color = sns.color_palette()

    def createWidget(self):
        self.title("Presentation_GUI")
        tabControl = ttk.Notebook(self)
        self.tab1 = tk.Frame(tabControl)
        self.createTab1()
        tabControl.add(self.tab1, text = 'EDA')
        self.tab2 = tk.Frame(tabControl)

        self.tab3 = tk.Frame(tabControl)
        self.createTab3()
        tabControl.add(self.tab3, text = 'Models')
        tabControl.pack(expand=1, fill="both")

    def addmenu(self, Menu):
        Menu(self)

    def createTab1(self):
        topframe = tk.Frame(self.tab1, height=80)
        #contentframe = tk.Frame(tab1)
        topframe.pack(side = tk.TOP)
        #contentframe.pack(side = tk.TOP)

        OrdersButton = tk.Menubutton(topframe, text = 'Distribution1')
        #OrdersButton.pack()
        ordersMenu = tk.Menu(OrdersButton, tearoff = False)
        ordersMenu.add_command(label = 'EDA1' )
        ordersMenu.add_command(label = 'EDA2')
        ordersMenu.add_command(label = 'EDA3')
        ordersMenu.add_command(label = 'EDA4')
        OrdersButton.config(menu=ordersMenu)

        ProductsButton = tk.Menubutton(topframe, text = 'Distribution2')
        #ProductsButton.pack()
        productsMenu = tk.Menu(ProductsButton, tearoff = False)
        productsMenu.add_command(label = 'EDA1')
        productsMenu.add_command(label = 'EDA2')
        productsMenu.add_command(label = 'EDA3')
        productsMenu.add_command(label = 'EDA4')
        ProductsButton.config(menu=productsMenu)

        OrdersButton.grid(row=0, column=0, sticky=tk.W)
        ProductsButton.grid(row=0, column=1)

        fig1 = Figure(figsize=(5, 4), dpi=100)
        self.ax1 = fig1.add_subplot(111)
        self.canvas1 = FigureCanvasTkAgg(fig1, master=self.tab1)
        self.canvas1.get_tk_widget().pack(side=tk.LEFT, fill=tk.BOTH, expand=1)
        self.canvas1._tkcanvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=1)
        fig2 = Figure(figsize=(5, 4), dpi=100)
        self.ax2 = fig2.add_subplot(111)
        self.canvas2 = FigureCanvasTkAgg(fig2, master=self.tab1)
        self.canvas2.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.canvas2._tkcanvas.pack(side=tk.RIGHT, fill=tk.BOTH, expand=1)

    def createTab3(self):
        self.ft2 = tkFont.Font(size = 18)
        tk.Label(self.tab3, text='Select Model:').pack()
        self.models = ttk.Combobox(self.tab3, values=['Logistic Regression', 'k-NearestNeighbor', 'Random Forest', 'HistGradientBoostingClassifier'])
        self.models.pack()
        tk.Button(self.tab3, text='Show Result', command=self.display_result).pack()
        fig3 = Figure(figsize=(5, 4), dpi=100)
        self.ax1 = fig3.add_subplot(111)
        self.canvas3 = FigureCanvasTkAgg(fig3, master=self.tab3)
        self.canvas3.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.canvas3._tkcanvas.pack(side=tk.RIGHT, fill=tk.BOTH, expand=1)
        self.modelText = tk.Text(self.tab3)
        self.modelText.pack(side = tk.LEFT, fill = tk.BOTH, expand = True)

    def display_result(self):
        modelName = self.models.get()
        if modelName == 'Logistic Regression':

            self.modelText.delete(1.0, tk.END)
            self.modelText.insert(tk.END, "Classification Report:\n" + str(classification_report(y_test, LRy_pred)) + "\n" + "Accuracy : " + str((accuracy_score(y_test, LRy_pred) * 100)) + "\n" + "ROC_AUC : " + str((roc_auc_score(y_test, LRy_pred_score[:, 1]) * 100)))

            self.canvas3.get_tk_widget().destroy()
            self.canvas3._tkcanvas.destroy()
            fig = self.draw_cm(LRy_pred)
            self.canvas3 = FigureCanvasTkAgg(fig, master=self.tab3)
            self.canvas3.draw()
            self.canvas3.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            self.canvas3._tkcanvas.pack(side=tk.RIGHT, fill=tk.BOTH, expand=1)

        elif modelName == 'k-NearestNeighbor':

            self.modelText.delete(1.0, tk.END)
            self.modelText.insert(tk.END, "Classification Report:\n" + str(
                classification_report(y_test, KNNy_pred)) + "\n" + "Accuracy : " + str(
                (accuracy_score(y_test, KNNy_pred) * 100)) + "\n" + "ROC_AUC : " + str(
                (roc_auc_score(y_test, KNNy_pred_score[:, 1]) * 100)))

            self.canvas3.get_tk_widget().destroy()
            self.canvas3._tkcanvas.destroy()
            fig = self.draw_cm(KNNy_pred)
            self.canvas3 = FigureCanvasTkAgg(fig, master=self.tab3)
            self.canvas3.draw()
            self.canvas3.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            self.canvas3._tkcanvas.pack(side=tk.RIGHT, fill=tk.BOTH, expand=1)
        elif modelName == 'Random Forest':

            self.modelText.delete(1.0, tk.END)
            self.modelText.insert(tk.END, "Classification Report:\n" + str(
                classification_report(y_test, RFy_pred)) + "\n" + "Accuracy : " + str(
                (accuracy_score(y_test, RFy_pred) * 100)) + "\n" + "ROC_AUC : " + str(
                (roc_auc_score(y_test, RFy_pred_score[:, 1]) * 100)))

            self.canvas3.get_tk_widget().destroy()
            self.canvas3._tkcanvas.destroy()
            fig = self.draw_cm(RFy_pred)
            self.canvas3 = FigureCanvasTkAgg(fig, master=self.tab3)
            self.canvas3.draw()
            self.canvas3.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            self.canvas3._tkcanvas.pack(side=tk.RIGHT, fill=tk.BOTH, expand=1)
        else:

            self.modelText.delete(1.0, tk.END)
            try:
                self.modelText.insert(tk.END, "Classification Report:\n" + str(
                    classification_report(y_test, HGBC_pred)) + "\n" + "Accuracy : " + str(
                    (accuracy_score(y_test, HGBC_pred) * 100)) + "\n" + "ROC_AUC : " + str(
                    (roc_auc_score(y_test, HGBC_pred_score[:, 1]) * 100)))
            except ValueError:
                pass

            self.canvas3.get_tk_widget().destroy()
            self.canvas3._tkcanvas.destroy()
            fig = self.draw_cm(HGBC_pred)
            self.canvas3 = FigureCanvasTkAgg(fig, master=self.tab3)
            self.canvas3.draw()
            self.canvas3.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            self.canvas3._tkcanvas.pack(side=tk.RIGHT, fill=tk.BOTH, expand=1)


    def draw_cm(self, y_pred):
        conf_matrix = confusion_matrix(y_test, y_pred)
        df_cm = pd.DataFrame(conf_matrix, index=['0', '1'], columns=['0', '1'])

        f, ax = plt.subplots(figsize=(5, 4))
        hm = sns.heatmap(df_cm, cbar=False, annot=True, square=True, fmt='d', annot_kws={'size': 20},
                         yticklabels=df_cm.columns, xticklabels=df_cm.columns)
        hm.yaxis.set_ticklabels(hm.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=20)
        hm.xaxis.set_ticklabels(hm.xaxis.get_ticklabels(), rotation=0, ha='right', fontsize=20)
        plt.ylabel('True label', fontsize=20)
        plt.xlabel('Predicted label', fontsize=20)
        return f



class MyMenu():
    def __init__(self, root):
        self.root = root
        self.menubar = tk.Menu(self.root)
        # add menu to root
        root.config(menu=self.menubar)

        self.myMenu = tk.Menu(self.menubar)
        self.myMenu.add_command(label = "About", command = self.about)

        self.myMenu.add_separator()
        self.myMenu.add_command(label = "quit", command = root.quit)

        # add menu to Menu
        self.menubar.add_cascade(label = "Menu", menu = self.myMenu)

    def about(self):
        pass


# load and preprocess
def Load_Preprocess():
    global X_train
    global X_test
    global y_train
    global y_test
    global LRy_pred
    global LRy_pred_score
    global KNNy_pred
    global KNNy_pred_score
    global RFy_pred
    global RFy_pred_score
    global HGBC_pred
    global HGBC_pred_score

    # read data
    data = pd.read_csv("aug_train.csv")
    # preprocessing
    data = data.drop(["enrollee_id","city"],axis=1)

    # change some values to be understood easily
    data["company_size"].unique()
    for i in range(len(data.index)):
        if data['company_size'][i] == '10/49':
            data['company_size'][i] = '10-49'

    data["experience"].unique()
    for i in range(len(data.index)):
        if data['experience'][i] == '>20':
            data['experience'][i] = '21'
        elif data['experience'][i] == '<1':
            data['experience'][i] = '0'

    data["last_new_job"].unique()
    for i in range(len(data.index)):
        if data['last_new_job'][i] == '>4':
            data['last_new_job'][i] = '5'
        elif data['last_new_job'][i] == 'never':
            data['last_new_job'][i] = '0'

    retarget = {0.0: 'Not looking for job change',
                1.0: 'Looking for job change'}
    data['target'] = data['target'].map(retarget)

    retarget2 = {'Not looking for job change': 0,
                 'Looking for job change': 1}
    data['target'] = data['target'].map(retarget2)





    # convert the necessary columns to a numeric format
    data['experience'] = data['experience'].astype(np.float).astype("Int32")
    data['last_new_job'] = data['last_new_job'].astype(np.float).astype("Int32")

    # specify the predictors and target variable
    X = data.drop(["target"],axis = 1)
    y = data["target"]

    # fill na
    X['experience'] = X['experience'].astype('float64').fillna(X['experience'].mean())
    X['last_new_job'] = X['last_new_job'].astype('float64').fillna(X['last_new_job'].mean())
    X['training_hours'] = X['training_hours'].astype('float64').fillna(X['training_hours'].mean())

    # # standerization and centralization
    # X.dropna(how='any')
    sc = StandardScaler()
    X["city_development_index"] = sc.fit_transform(X["city_development_index"].values.reshape(-1,1))
    X["experience"] = sc.fit_transform(X["experience"].values.reshape(-1,1))
    X["last_new_job"] = sc.fit_transform(X["last_new_job"].values.reshape(-1,1))
    X["training_hours"] = sc.fit_transform(X["training_hours"].values.reshape(-1,1))

    # encoding categorical features with OneHotEncoder()
    columns_categorical = ["gender","relevent_experience","enrolled_university","education_level","major_discipline","company_size","company_type"]
    columns_numerical = ["city_development_index","experience","last_new_job","training_hours"]

    X = pd.get_dummies(X, columns = columns_categorical)

    # label target variable
    le = LabelEncoder()
    y = le.fit_transform(y)

    # split the dataset into train and test
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=2000)
    LRy_pred, LRy_pred_score = LRModel()
    HGBC_pred, HGBC_pred_score = HGBCModel()
    KNNy_pred, KNNy_pred_score = KNNModel()
    RFy_pred, RFy_pred_score = RFModel()


def LRModel():
    logt = LogisticRegression()
    logt.fit(X_train,y_train)
    y_pred = logt.predict(X_test)
    y_pred_score = logt.predict_proba(X_test)
    return y_pred, y_pred_score

def HGBCModel():
    hgbc = HistGradientBoostingClassifier(random_state=42)
    hgbc.fit(X_train, y_train)

    y_pred = hgbc.predict(X_test)
    y_pred_score = hgbc.predict_proba(X_test)
    return y_pred, y_pred_score

def KNNModel():
    clf_KNN = KNeighborsClassifier(n_neighbors=5)
    clf_KNN.fit(X_train, y_train)

    y_pred = clf_KNN.predict(X_test)
    y_pred_score = clf_KNN.predict_proba(X_test)
    return y_pred, y_pred_score

def RFModel():
    clf = RandomForestClassifier(n_estimators=90)
    clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    y_pred_score = clf.predict_proba(X_test)
    return y_pred, y_pred_score

def main():
    app = Application()
    app.addmenu(MyMenu)
    app.mainloop()

if __name__ == '__main__':
    Load_Preprocess()
    main()
